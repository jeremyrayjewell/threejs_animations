import * as THREE from 'three';

// Create scene
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB); // Sky blue background

// Create camera
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 5, 15);
camera.lookAt(0, 0, 0);

// Create renderer
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// Add lights
const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambientLight);

const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
directionalLight.position.set(10, 10, 5);
directionalLight.castShadow = true;
directionalLight.shadow.mapSize.width = 2048;
directionalLight.shadow.mapSize.height = 2048;
scene.add(directionalLight);

// Character building area - we'll build your custom character here using Three.js geometries
// Available geometries: BoxGeometry, SphereGeometry, CylinderGeometry, ConeGeometry, etc.

// Example: Let's start with a simple character base
// Head
const headGeometry = new THREE.SphereGeometry(1, 32, 32);
const headMaterial = new THREE.MeshStandardMaterial({ color: 0xffdbac }); // Skin color
const head = new THREE.Mesh(headGeometry, headMaterial);
head.position.y = 4;
head.castShadow = true;
scene.add(head);

// Body
const bodyGeometry = new THREE.CylinderGeometry(0.8, 1.2, 3, 8);
const bodyMaterial = new THREE.MeshStandardMaterial({ color: 0x4169e1 }); // Blue shirt
const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
body.position.y = 1;
body.castShadow = true;
scene.add(body);

// Store character parts for animation
let characterParts = {
  head: head,
  body: body
};

// Animation loop
function animate() {
  requestAnimationFrame(animate);
  
  const time = performance.now() * 0.001;
  
  // Simple head bobbing animation
  if (characterParts.head) {
    characterParts.head.rotation.y = Math.sin(time) * 0.2;
    characterParts.head.position.y = 4 + Math.sin(time * 2) * 0.1;
  }
  
  renderer.render(scene, camera);
}

// Handle window resize
window.addEventListener('resize', function() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// Start animation
animate();
    
    // Get the bounding box to understand the model size
    const box = new THREE.Box3().setFromObject(model);
    const size = box.getSize(new THREE.Vector3());
    const center = box.getCenter(new THREE.Vector3());
    
    // Try scaling up in case it's too small
    model.scale.set(4, 4, 4);
    model.position.set(0, 0, 5); // Closer to camera, centered
    
    // Make materials metallic and shiny
    model.traverse((child) => {
      if (child.isMesh) {
        const material = child.material;
        if (material) {
          // If it's a standard material, make it metallic
          if (material.isMeshStandardMaterial || material.isMeshPhysicalMaterial) {
            material.metalness = 0.3; // Some metallic but not too much
            material.roughness = 0.1; // Very smooth/shiny
            material.envMapIntensity = 2.0; // Strong reflections
            // Make colors darker
            if (material.color) {
              material.color.multiplyScalar(0.8); // Make colors 20% darker
            }
          } else {
            // Convert other materials to MeshStandardMaterial for metallic properties
            const darkColor = material.color ? material.color.clone().multiplyScalar(0.8) : new THREE.Color(0xcccccc);
            const newMaterial = new THREE.MeshStandardMaterial({
              color: darkColor,
              map: material.map,
              metalness: 0.3,
              roughness: 0.1,
              envMapIntensity: 2.0
            });
            child.material = newMaterial;
          }
        }
      }
    });
    
    scene.add(model);
    modelRef = model; // Store reference for animation
    
    // Load psx_style_flip_phone.glb specifically
    loader.load(
      '/models/psx_style_flip_phone.glb',
      function (gltf) {
        console.log('PSX flip phone model loaded successfully');
        const phoneModel = gltf.scene;
        
        // Check for built-in animations
        if (gltf.animations && gltf.animations.length > 0) {
          console.log('Flip phone has', gltf.animations.length, 'built-in animations:');
          gltf.animations.forEach((clip, index) => {
            console.log(`Animation ${index}: ${clip.name}, duration: ${clip.duration}s`);
          });
        } else {
          console.log('Flip phone has no built-in animations');
        }
        
        phoneModel.scale.set(30, 30, 30);
        phoneModel.position.set(20, -10, -30);
        
        scene.add(phoneModel);
        phoneRef = phoneModel; // Store reference for animation
        console.log('PSX flip phone added at (10,0,0)');
      },
      undefined,
      function (error) {
        console.error('PSX flip phone error:', error.message);
      }
    );
    
    // Load Animated-Human_by_get3dmodels.glb
    loader.load(
      '/models/Animated-Human_by_get3dmodels.glb',
      function (gltf) {
        console.log('Animated human model loaded successfully');
        const humanModel = gltf.scene;
        
        humanModel.scale.set(4, 4, 4);
        humanModel.position.set(-12, -10, 4); // Closer to camera, to the left
        
        // Set up animation mixer and play animations
        if (gltf.animations && gltf.animations.length > 0) {
          mixer = new THREE.AnimationMixer(humanModel);
          
          // Play all animations with crossfade looping to eliminate stutter
          gltf.animations.forEach((clip, index) => {
            console.log('Playing animation:', clip.name);
            
            // Create two identical actions for crossfading
            const action1 = mixer.clipAction(clip);
            const action2 = mixer.clipAction(clip.clone());
            
            action1.setLoop(THREE.LoopOnce, 1);
            action2.setLoop(THREE.LoopOnce, 1);
            
            action1.clampWhenFinished = false;
            action2.clampWhenFinished = false;
            
            // Start the first action
            action1.play();
            
            // Set up crossfading at 90% of animation duration
            const duration = clip.duration;
            const crossfadeTime = duration * 0.1; // 10% crossfade
            
            mixer.addEventListener('finished', (event) => {
              if (event.action === action1) {
                action2.reset().play();
                action1.crossFadeTo(action2, crossfadeTime, true);
              } else if (event.action === action2) {
                action1.reset().play();
                action2.crossFadeTo(action1, crossfadeTime, true);
              }
            });
          });
        }
        
        scene.add(humanModel);
        humanRef = humanModel; // Store reference for animation
        console.log('Animated human added at (-10,0,0)');
      },
      undefined,
      function (error) {
        console.error('Animated human error:', error.message);
      }
    );
    
    // Re-render after model is added
    animate(); // Start animation loop instead of single render
  }
);

// Animation loop
function animate() {
  requestAnimationFrame(animate);
  
  const time = performance.now() * 0.001; // Convert to seconds
  
  // Update animation mixer for human model with consistent timing
  if (mixer) {
    const deltaTime = 0.016; // Fixed 60fps timing for consistency
    mixer.update(deltaTime);
  }
  
  // Slowly rotate the model if it's loaded
  if (modelRef) {
    modelRef.rotation.y += 0.005; // Slow rotation around Y-axis
  }
  
  // Rotate the flip phone if it's loaded
  if (phoneRef) {
    phoneRef.rotation.y -= 0.008; // Opposite direction and faster
  }
  
  renderer.render(scene, camera);
}

// Simple render function for fallback
function render() {
  renderer.render(scene, camera);
}

// Handle window resize
window.addEventListener('resize', function() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  render(); // Re-render after resize
});

// Initial render
render();